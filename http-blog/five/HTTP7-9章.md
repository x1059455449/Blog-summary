## HTTP 的缺点 ##

1.通信使用明文（不加密），内容可能会被窃听

2.不验证通信方的身份，因此有可能遭遇伪装

3.无法证明报文的完整性，所以有可能已遭篡改

## 中间人攻击 ##

无法证明报文完整性，可能已遭篡改。所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

中间1.2img

## 如何防止篡改 ##

虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。

可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。为了有效防止这些弊端，有必要使用 HTTPS。SSL提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。

## HTTPS ##

为饿了解决上述锁存的的问题，HTTPS随之出现。HTTPS 是身披 SSL 外壳的 HTTP。先介绍HTTPS通信和SSL 和 TLS。

> HTTPS 通信

P154大图+步骤

> SSL 和 TLS 

上一篇博客

## HTTP认证方式 ##

###HTTP/1.1 使用的认证方式：

	BASIC 认证（基本认证）
	DIGEST 认证（摘要认证）
	SSL 客户端认证
	FormBase 认证（基于表单认证）
	Windows 统一认证（Keberos 认证、NTLM 认证）

## BASIC 认证 ##

img

步骤 1： 当请求的资源需要 BASIC 认证时，服务器会随状态码 401
Authorization Required，返回带 WWW-Authenticate 首部字段的响应。
该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字符串
（realm）。
步骤 2： 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将
用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码
构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。
假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这
样的字符串。然后经过 Base64 编码，最后的结果即是
Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，
发送请求。
当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，
浏览器会自动完成到 Base64 编码的转换工作。
步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会对认证
信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI
资源的响应。
BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要
任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID
和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程
中，如果被人窃听，被盗的可能性极高。
另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法
实现认证注销操作，这也是问题之一。
BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安
全性等级，因此它并不常用。

## DIGEST 认证 ##

img

步骤 1： 请求需认证的资源时，服务器会随着状态码 401
Authorization Required，返 回带 WWW-Authenticate 首部字段的响应。
该字段内包含质问响应方式认证所需的临时质询码（随机数，
nonce）。
首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的
信息。客户端就是依靠向服务器回送这两个值进行认证的。
nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符
串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依
赖服务器的具体实现。
步骤 2： 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认
证必须的首部字段 Authorization 信息。
首部字段 Authorization 内必须包含 username、realm、nonce、uri 和
response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到
的响应中的字段。
username 是 realm 限定范围内可进行认证的用户名。
uri（digest-uri）即 Request-URI 的值，但考虑到经代理转发后
Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri
内。
response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符
串，形成响应码。
响应中其他的实体请参见第 6 章的请求首部字段 Authorization。另
外，有关 Request-Digest 的计算规则较复杂，有兴趣的读者不妨深入
学习一下 RFC2617。
步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会确认认
证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。
并且这时会在首部字段 Authentication-Info 写入一些认证成功的相关信
息。
DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的
客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护
机制，但并不存在防止用户伪装的保护机制。
DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不
到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也
有所受限。

## SSL 客户端认证 ##

从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，
即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被
第三者冒充。利用 SSL客户端认证则可以避免该情况的发生。
SSL客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借
客户端证书认证，服务器可确认访问是否
来自已登录的客户端。

为达到 SSL客户端认证的目的，需要事先将客户端证书分发给客户
端，且客户端必须安装此证书。
步骤 1： 接收到需要认证资源的请求，服务器会发送 Certificate
Request 报文，要求客户端提供客户端证书。
步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信
息以 Client Certificate 报文方式发送给服务器。步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。第一个认证因素的 SSL客户端证书用来认证客户端计算机，
另一个认证因素的密码则用来确定这是用户本人的行为。

## 基于表单认证(常用) ##

类似各大网站的登陆，通过表单来验证登录

## HTTP 的瓶颈 ##

	1.一条连接上只可发送一个请求。
	2.请求只能从客户端开始。客户端不可以接收除响应以外的指令。
	3.请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。
	4.发送冗长的首部。每次互相发送相同的首部造成的浪费较多。


## WebSocket ##


## 各种攻击 ##









